'''
문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.
'''


def dfs():
    if len(s) == m:
        print(' '.join(map(str, s)))
        return
    for i in range(1, n+1):
        if visited[i]:
            continue
        visited[i] = True
        s.append(i)
        dfs()
        s.pop()
        print(s)
        print(visited)
        visited[i] = False
            

n, m = map(int, input().split())
s = []
visited = [False] * (n+1)

dfs()

'''
함수를 호출하고 해를 출력할 조건으로 s라는 빈 배열과 m의 값이 같을 때 수와 공백으로 출력하도록 하고

for문을 이용해 모든 방법을 찾아볼 수 있도록 맨 앞의 수를 지정해준다. 수들의 중복 요소를 검사하는 조건문을 작성하고 중복이 아니라면 리스트 s에 그 수를 추가하고 다시 함수를 호출한다. 

재귀함수 부분에서 예를 들어 n=3, m=2일 때

i=1, s = [1] -> [1, 2] -> [1] -> [1, 3]

i=2, s = [2] -> [2, 1] -> [2] -> [2, 3]

i=3, s = [3] -> [3, 1] -> [3] -> [3, 2]

로 출력하고 pop 하며 결과를 계속 출력하게 된다. 1부터 들어가기 때문에 오름차순으로 잘 출력되게 된다. m이 커진다고 해도 방식은 같다 1부터 n까지 수를 하나씩 넣어 놓고 길이가 m이 될 때까지 재귀하는 것이다.

https://velog.io/@yusuk6185/%EB%B0%B1%EC%A4%80-15649-N%EA%B3%BC-M-1-%ED%8C%8C%EC%9D%B4%EC%8D%AC-with-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9
'''